<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stories Maker 9:16</title>

<style>
  :root{
    --bg:#0b0c10;
    --panel:#12141a;
    --stroke:#232736;
    --text:#e9ecf2;
    --muted:#9aa3b2;
    --btn:#2a6df5;
  }
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  }
  .wrap{max-width:460px;margin:18px auto;padding:16px;}
  .card{
    background:var(--panel);
    border:1px solid var(--stroke);
    border-radius:16px;
    padding:14px;
  }
  h2{margin:0 0 10px;font-size:18px;font-weight:800}
  label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
  input[type="file"]{width:100%;color:var(--muted)}
  textarea{
    width:100%;
    height:110px;
    border-radius:12px;
    border:1px solid var(--stroke);
    background:#0f1118;
    color:var(--text);
    padding:12px;
    font-size:16px;
    line-height:1.35;
    resize:vertical;
    box-sizing:border-box;
  }
  select{
    width:100%;
    border-radius:12px;
    border:1px solid var(--stroke);
    background:#0f1118;
    color:var(--text);
    padding:10px 12px;
    font-size:16px;
    box-sizing:border-box;
  }
  button{
    width:100%;
    padding:12px 14px;
    border-radius:12px;
    border:0;
    background:var(--btn);
    color:#fff;
    font-size:16px;
    font-weight:800;
    cursor:pointer;
    margin-top:12px;
  }

  canvas{display:none;} /* рисуем в canvas, показываем img */
  #resultImg{
    width:100%;
    border-radius:18px;
    margin-top:14px;
    display:none;
    background:#000;
    -webkit-touch-callout: default;
  }
  .small{opacity:.65;font-size:13px;margin-top:10px;text-align:center}
</style>
</head>
<body>

<div class="wrap">
  <div class="card">
    <h2>Stories Generator 9:16</h2>

    <label>Фото</label>
    <input type="file" id="imageInput" accept="image/*" />

    <label>Текст</label>
    <textarea id="textInput" placeholder="Введите текст..."></textarea>

    <label>Положение текста</label>
    <select id="textPosition">
      <option value="bottom" selected>Снизу</option>
      <option value="top">Сверху</option>
    </select>

    <button id="btn">Создать</button>

    <canvas id="canvas" width="1080" height="1920"></canvas>
    <img id="resultImg" alt="result" />

    <div class="small">Сохранение: долгий тап по картинке → «Сохранить в Фото»</div>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { alpha: false });
document.getElementById("btn").addEventListener("click", generate);

function wrapTextSmart(ctx, text, maxWidth) {
  const cleaned = (text || "").trim().replace(/\s+/g, " ");
  if (!cleaned) return [];

  if (ctx.measureText(cleaned).width <= maxWidth) return [cleaned];

  const words = cleaned.split(" ");
  const lines = [];
  let line = "";

  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (ctx.measureText(test).width <= maxWidth) line = test;
    else { if (line) lines.push(line); line = w; }
  }
  if (line) lines.push(line);

  // убрать "одинокое" слово в последней строке
  if (lines.length >= 2) {
    const last = lines[lines.length - 1];
    const prev = lines[lines.length - 2];

    if (last.split(" ").length === 1 && prev.split(" ").length >= 2) {
      const prevWords = prev.split(" ");
      const moved = prevWords[prevWords.length - 1];
      const newPrev = prevWords.slice(0, -1).join(" ");
      const newLast = moved + " " + last;

      if (ctx.measureText(newPrev).width <= maxWidth &&
          ctx.measureText(newLast).width <= maxWidth) {
        lines[lines.length - 2] = newPrev;
        lines[lines.length - 1] = newLast;
      }
    }
  }
  return lines;
}

function drawBottomGradient(W, H) {
  const gradientHeight = 760;
  const g = ctx.createLinearGradient(0, H - gradientHeight, 0, H);
  g.addColorStop(0.00, "rgba(0,0,0,0.00)");
  g.addColorStop(0.55, "rgba(0,0,0,0.18)");
  g.addColorStop(1.00, "rgba(0,0,0,0.60)");
  ctx.fillStyle = g;
  ctx.fillRect(0, H - gradientHeight, W, gradientHeight);
}

function drawTopGradient(W, H) {
  const gradientHeight = 520;
  const g = ctx.createLinearGradient(0, 0, 0, gradientHeight);
  g.addColorStop(0.00, "rgba(0,0,0,0.55)");
  g.addColorStop(0.55, "rgba(0,0,0,0.18)");
  g.addColorStop(1.00, "rgba(0,0,0,0.00)");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, gradientHeight);
}

function exportToImage() {
  const resultImg = document.getElementById("resultImg");
  resultImg.src = canvas.toDataURL("image/jpeg", 0.95);
  resultImg.style.display = "block";
  resultImg.setAttribute("draggable", "false");
  resultImg.style.webkitTouchCallout = "default";
}

function setTextStyle() {
  // ВАЖНО: выставляем стиль ПОСЛЕ градиента, иначе fillStyle перезапишется
  ctx.font = "800 70px system-ui,-apple-system,Segoe UI,Roboto,Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  // белый текст
  ctx.fillStyle = "#ffffff";

  // тень как в IG
  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 6;

  // лёгкая обводка (очень помогает читаемости)
  ctx.lineWidth = 6;
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
}

function resetEffects() {
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
}

function generate() {
  const file = document.getElementById("imageInput").files[0];
  const text = document.getElementById("textInput").value;
  const position = document.getElementById("textPosition").value;
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    const img = new Image();
    img.onload = () => {
      const W = canvas.width, H = canvas.height;

      // 1) Фото
      ctx.clearRect(0, 0, W, H);
      const scale = Math.max(W / img.width, H / img.height);
      const x = (W - img.width * scale) / 2;
      const y = (H - img.height * scale) / 2;
      ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

      // 2) Градиент (сначала!)
      if (position === "bottom") drawBottomGradient(W, H);
      else drawTopGradient(W, H);

      // 3) Стиль текста (после градиента!)
      setTextStyle();

      // 4) Ширина и переносы
      const sidePadding = 84;
      const maxWidth = W - sidePadding * 2;
      const lines = wrapTextSmart(ctx, text, maxWidth);
      const lineHeight = 84;
      const blockH = lines.length * lineHeight;

      // 5) Позиция текста
      let topY;
      if (position === "bottom") {
        const bottomOffset = 120; // ВЫШЕ/НИЖЕ: 90 ниже, 140 выше
        topY = H - blockH - bottomOffset;
      } else {
        const topOffset = 120;
        topY = topOffset;
      }

      // 6) Рисуем: сначала обводка, потом белая заливка (IG-приём)
      for (let i = 0; i < lines.length; i++) {
        const yy = topY + i * lineHeight;
        ctx.strokeText(lines[i], sidePadding, yy);
        ctx.fillText(lines[i], sidePadding, yy);
      }

      resetEffects();
      exportToImage();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}
</script>

</body>
</html>
