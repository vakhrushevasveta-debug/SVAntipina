<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stories Maker 9:16</title>

<style>
  :root{
    --bg:#0b0c10;
    --panel:#12141a;
    --stroke:#232736;
    --text:#e9ecf2;
    --muted:#9aa3b2;
    --btn:#2a6df5;
  }
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
  }
  .wrap{max-width:460px;margin:18px auto;padding:16px;}
  .card{
    background:var(--panel);
    border:1px solid var(--stroke);
    border-radius:16px;
    padding:14px;
  }
  h2{margin:0 0 10px;font-size:18px;font-weight:800}
  label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
  input[type="file"]{width:100%;color:var(--muted)}
  textarea{
    width:100%;
    height:110px;
    border-radius:12px;
    border:1px solid var(--stroke);
    background:#0f1118;
    color:var(--text);
    padding:12px;
    font-size:16px;
    line-height:1.35;
    resize:vertical;
    box-sizing:border-box;
  }
  select{
    width:100%;
    border-radius:12px;
    border:1px solid var(--stroke);
    background:#0f1118;
    color:var(--text);
    padding:10px 12px;
    font-size:16px;
    box-sizing:border-box;
  }
  button{
    width:100%;
    padding:12px 14px;
    border-radius:12px;
    border:0;
    background:var(--btn);
    color:#fff;
    font-size:16px;
    font-weight:800;
    cursor:pointer;
    margin-top:12px;
  }

  canvas{display:none;}
  #resultImg{
    width:100%;
    border-radius:18px;
    margin-top:14px;
    display:none;
    background:#000;
    -webkit-touch-callout: default;
  }
  .small{opacity:.65;font-size:13px;margin-top:10px;text-align:center}
</style>
</head>
<body>

<div class="wrap">
  <div class="card">
    <h2>Stories Generator 9:16</h2>

    <label>Фото</label>
    <input type="file" id="imageInput" accept="image/*" />

    <label>Текст</label>
    <textarea id="textInput" placeholder="Введите текст..."></textarea>

    <label>Положение текста</label>
    <select id="textPosition">
      <option value="bottom" selected>Снизу</option>
      <option value="top">Сверху</option>
    </select>

    <button id="btn">Создать</button>

    <canvas id="canvas" width="1080" height="1920"></canvas>
    <img id="resultImg" alt="result" />

    <div class="small">Сохранение: долгий тап по картинке → «Сохранить в Фото»</div>
  </div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { alpha: false });

document.getElementById("btn").addEventListener("click", generate);

function cleanText(text){
  return (text || "").trim().replace(/\s+/g, " ");
}

function wrapText(ctx, text, maxWidth){
  const cleaned = cleanText(text);
  if (!cleaned) return [];

  // Если помещается — 1 строка
  if (ctx.measureText(cleaned).width <= maxWidth) return [cleaned];

  const words = cleaned.split(" ");
  const lines = [];
  let line = "";

  for (const w of words) {
    const test = line ? (line + " " + w) : w;
    if (ctx.measureText(test).width <= maxWidth) {
      line = test;
    } else {
      if (line) lines.push(line);
      line = w;
    }
  }
  if (line) lines.push(line);

  // Попытка убрать "одинокое" слово в последней строке
  if (lines.length >= 2) {
    const last = lines[lines.length - 1];
    const prev = lines[lines.length - 2];

    const lastWords = last.split(" ");
    const prevWords = prev.split(" ");

    if (lastWords.length === 1 && prevWords.length >= 2) {
      const moved = prevWords[prevWords.length - 1];
      const newPrev = prevWords.slice(0, -1).join(" ");
      const newLast = moved + " " + last;

      if (ctx.measureText(newPrev).width <= maxWidth &&
          ctx.measureText(newLast).width <= maxWidth) {
        lines[lines.length - 2] = newPrev;
        lines[lines.length - 1] = newLast;
      }
    }
  }

  return lines;
}

function drawBottomGradient(W, H) {
  const gradientHeight = 760;
  const g = ctx.createLinearGradient(0, H - gradientHeight, 0, H);
  g.addColorStop(0.00, "rgba(0,0,0,0.00)");
  g.addColorStop(0.55, "rgba(0,0,0,0.18)");
  g.addColorStop(1.00, "rgba(0,0,0,0.60)");
  ctx.fillStyle = g;
  ctx.fillRect(0, H - gradientHeight, W, gradientHeight);
}

function drawTopGradient(W, H) {
  const gradientHeight = 520;
  const g = ctx.createLinearGradient(0, 0, 0, gradientHeight);
  g.addColorStop(0.00, "rgba(0,0,0,0.55)");
  g.addColorStop(0.55, "rgba(0,0,0,0.18)");
  g.addColorStop(1.00, "rgba(0,0,0,0.00)");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, gradientHeight);
}

function setTextStyle(fontPx){
  ctx.font = `800 ${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  // Белый текст
  ctx.fillStyle = "#ffffff";

  // Тень — читаемость, но без "грязи"
  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowBlur = Math.max(10, Math.round(fontPx * 0.28));
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = Math.max(4, Math.round(fontPx * 0.08));
}

function resetEffects(){
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
}

/**
 * Автоподбор: подбираем размер шрифта, чтобы:
 * - ширина строк ≤ maxWidth
 * - высота блока текста ≤ maxHeight (1/3 кадра)
 */
function autoFitText(text, maxWidth, maxHeight){
  const cleaned = cleanText(text);
  if (!cleaned) {
    return { fontPx: 70, lineHeight: 84, lines: [] };
  }

  // Диапазон размеров
  let fontPx = 72;      // старт (красиво и крупно)
  const minFont = 34;   // ниже уже мелко
  const step = 2;

  while (fontPx >= minFont) {
    setTextStyle(fontPx);

    // lineHeight чуть больше шрифта (как IG)
    const lineHeight = Math.round(fontPx * 1.18);

    const lines = wrapText(ctx, cleaned, maxWidth);
    const blockH = lines.length * lineHeight;

    // Влезаем по высоте?
    if (blockH <= maxHeight) {
      return { fontPx, lineHeight, lines };
    }

    fontPx -= step;
  }

  // Если текста очень много — возвращаем минимальный, всё равно ограничим 1/3
  setTextStyle(minFont);
  return { fontPx: minFont, lineHeight: Math.round(minFont * 1.18), lines: wrapText(ctx, cleaned, maxWidth) };
}

function exportToImage() {
  const resultImg = document.getElementById("resultImg");
  resultImg.src = canvas.toDataURL("image/jpeg", 0.95);
  resultImg.style.display = "block";
  resultImg.setAttribute("draggable", "false");
  resultImg.style.webkitTouchCallout = "default";
}

function generate(){
  const file = document.getElementById("imageInput").files[0];
  const text = document.getElementById("textInput").value;
  const position = document.getElementById("textPosition").value;
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (e) => {
    const img = new Image();
    img.onload = () => {
      const W = canvas.width, H = canvas.height;

      // 1) Фото (cover)
      ctx.clearRect(0, 0, W, H);
      const scale = Math.max(W / img.width, H / img.height);
      const dx = (W - img.width * scale) / 2;
      const dy = (H - img.height * scale) / 2;
      ctx.drawImage(img, dx, dy, img.width * scale, img.height * scale);

      // 2) Градиент (под позицию)
      if (position === "bottom") drawBottomGradient(W, H);
      else drawTopGradient(W, H);

      // 3) Ограничения по размеру блока текста
      const sidePadding = 84;
      const maxWidth = W - sidePadding * 2;

      const maxTextHeight = Math.floor(H / 3); // <= 1/3 кадра

      // 4) Подбираем размер шрифта под объём текста
      const fit = autoFitText(text, maxWidth, maxTextHeight);

      // Если текста нет — просто экспорт
      if (!fit.lines.length) {
        resetEffects();
        exportToImage();
        return;
      }

      // 5) Позиция текста (внутри 1/3)
      let topY;
      if (position === "bottom") {
        // блок должен сидеть внизу, но внутри ограниченной зоны
        // bottomOffset — отступ от низа (меньше -> ниже)
        const bottomOffset = 120;
        topY = H - (fit.lines.length * fit.lineHeight) - bottomOffset;

        // гарантируем, что не улетит выше чем 2/3 кадра
        const minTop = H - maxTextHeight;
        if (topY < minTop) topY = minTop;
      } else {
        const topOffset = 120;
        topY = topOffset;

        // гарантируем, что блок не будет выше ограниченной зоны
        const maxTop = maxTextHeight - (fit.lines.length * fit.lineHeight);
        if (topY > maxTop) topY = Math.max(24, maxTop);
      }

      // 6) Рисуем текст (без обводки!)
      setTextStyle(fit.fontPx);
      for (let i = 0; i < fit.lines.length; i++) {
        ctx.fillText(fit.lines[i], sidePadding, topY + i * fit.lineHeight);
      }

      resetEffects();
      exportToImage();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
}
</script>

</body>
</html>
